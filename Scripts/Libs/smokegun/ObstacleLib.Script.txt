/*********************************************
 * Obstacle Library                           *
 * Author:  smokegun                          *
 *                                            *
 * Obstacle functions.                        *
 *********************************************/

#Include "TextLib" as TL
#Include "MathLib" as ML

#Include "Libs/Nadeo/Json2.Script.txt" as Json
#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map
#Include "Libs/Nadeo/Ladder.Script.txt" as Ladder
#Include "Libs/Nadeo/ShootMania/SM3.Script.txt" as SM
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/Log.Script.txt" as Log
#Include "Libs/Nadeo/TabsServer.Script.txt" as Tabs

#Include "Libs/smokegun/Constants.Script.txt" as Constants
#Include "Libs/smokegun/Player.Script.txt" as Player
#Include "Libs/smokegun/Tools.Script.txt" as Tools
#Include "Libs/smokegun/Weapons.Script.txt" as Weapons
#Include "Libs/smokegun/ObstacleRecords.Script.txt" as API

#Include "Libs/smokegun/CPTimes.Script.txt" as CPTimes

#Include "Libs/smokegun/UI/TimeDiff.Script.txt" as TimeDiff
#Include "Libs/smokegun/Settings.Script.txt" as Settings
#Include "Libs/smokegun/Score.Script.txt" as ObsScores


/*********************************************
  CONSTANTS
 *********************************************/

#Const  Version     "2017-07-10"
#Const  ScriptName  "ObstacleLib.Script.txt"


/*********************************************
  GLOBALES
 *********************************************/

// Map
declare Ident G_StartSpawnId;
declare Integer G_CheckpointsTotal;
declare Integer G_Mode;


/*********************************************
  FUNCTIONS
 *********************************************/
Void SetMode(Integer _Mode) {
    G_Mode = _Mode;
}

Integer GetMode() {
    return G_Mode;
}

/**
 * Initialize a player
 *
 */
Void NewPlayer(CSmPlayer _Player)
{
    Player::InitPlayer(_Player);
    if (Settings::GetEnableRecords()) {
        API::ReplaceOrCreatePlayer(_Player);
    }
    Ladder::AddPlayer(_Player.Score);

    declare UI <=> UIManager.GetUI(_Player);
    if (UI == Null) return;
    Tabs::UseTabs(UI, "ScoresTab");
    if (Hud == Null || Hud.ScoresTable == Null) return;
    Hud.ScoresTable.SetColumnValue (_Player.Score, "BestTime", "--:--:--");
    Hud.ScoresTable.SetColumnValue (_Player.Score, "RS", 0);
}

Void UpdatePlayersSkin(Ident SkinId) {
    foreach (Player in Players) {
        if (Settings::GetForceInvisibleSkin() && Player.ForceModelId == NullId) {
            Player.ForceModelId = SkinId;
        }

        if (!Settings::GetForceInvisibleSkin() && Player.ForceModelId != NullId) {
            Player.ForceModelId = NullId;
        }

        if (Player.IsHighlighted != Settings::GetEnablePlayerHighlight()) {
            Player.IsHighlighted = Settings::GetEnablePlayerHighlight();
        }
    }
}


/**
 * Initialize the map (count cp, find spawn, send api request)
 *
 * Returns: boolean is the map valid
 */
Boolean PrepareMap() {
    if (Settings::GetEnableRecords()) {
        API::ReplaceOrCreateMap();
    }

    G_StartSpawnId = NullId;
    G_CheckpointsTotal = 0;

    // Count checkpoints and init markers for portals
    // We save checkpoints to CheckpointOrders to count multiple checkpoints with the same order once
    declare Integer[] CheckpointOrders = [];

    foreach (Landmark in MapLandmarks) {
        if (Landmark.Gauge != Null)
            Landmark.Gauge.ValueReal = 1.0;

        if (Tools::IsCheckpoint(Landmark)) {
            if (Landmark.Order == 0 || !CheckpointOrders.exists(Landmark.Order)) {
                G_CheckpointsTotal += 1;
                CheckpointOrders.add(Landmark.Order);
            }
        }
    }

    // Publish the numbers of checkpoint for the UI
    declare netwrite Integer Net_CheckpointsTotal for Teams[0];
    Net_CheckpointsTotal = G_CheckpointsTotal;

    CPTimes::StartMap(G_CheckpointsTotal);
    ObsScores::SetCheckpointTotal(G_CheckpointsTotal);
    ObsScores::OnMapBegin();

    // Search start spawn
    foreach (SpawnLandmark in MapLandmarks_PlayerSpawn) {
        if (Tools::IsSpawn(SpawnLandmark)) {
            G_StartSpawnId = SpawnLandmark.Id;
            break;
        }
    }

    //TODO: Show warning when playing old map, to prevent crash with fast rs and poles as cp
    if (!MapLandmarks_PlayerSpawn.existskey(G_StartSpawnId)) {
        Log::Log("ERROR: No Start Spawn on this Map!");
        UIManager.UIAll.SendChat("$f00ERROR: No Start Spawn on this Map!");
        return False;
    }

    declare MapVersion = Map::GetMapTypeVersion();
    if (MapVersion < 2) {
        UIManager.UIAll.SendChat("$f00WARNING: This is an old map, please disable fast respawn in the settings if some cps are made with poles!");
    }

    return True;
}

Integer GetCheckpointsTotal() {
	return G_CheckpointsTotal;
}

/////////////////////////////////////////////////////////////////
///////////////////// XMLRPC CALLBACKS  /////////////////////////
/////////////////////////////////////////////////////////////////

/**
 * Send a xmlrpc callback with a predefined payload
 *
 */
Void Private_SendXmlRpcCallback(Text _CallbackName, CSmPlayer _Player, Integer _RunTime, Ident _CheckpointId) {
    if (_Player == Null || _Player.IsFakePlayer || _Player.Score == Null || _CallbackName == "" || _RunTime <= 0) return;

    declare LastCPTimes = Player::getLastCPTimes(_Player);
    declare JSON =
        """{
            "Player":
            {
                "Name": "{{{Json::EscapeText(_Player.User.Name)}}}",
                "Login": "{{{Json::EscapeText(_Player.User.Login)}}}"
            },
            "Run":
            {
                "Time": {{{_RunTime}}},
                "RespawnCount": {{{Player::getRespawnCount(_Player)}}},
                "CheckpointIndex": {{{LastCPTimes.count - 1}}},
                "CheckpointId": "{{{_CheckpointId}}}"
            }
        }""";

    XmlRpc.SendCallback(_CallbackName, JSON);
}

/**
 * Side effects when a player finishes a run
 *   - XmlRpc for compatibility with controllers such as ManiaControl
 *   - Api to save records online
 *
 */
Void Private_SendFinishedRun(CSmPlayer _Player, Integer _Run, Ident _GoalId) {
    Private_SendXmlRpcCallback("OnFinish", _Player, _Run, _GoalId);
    if (Settings::GetEnableRecords()) {
        API::PlayerFinished(_Player);
    }
}

/////////////////////////////////////////////////////////////////
///////////////////// SCORESTABLE SYNC  /////////////////////////
/////////////////////////////////////////////////////////////////

/**
 * Update the column best time
 *
 * Arguments: CSmPlayer _Player player to update
 */
Void Private_UpdatePlayerBestTime(CSmPlayer _Player) {
    if (Hud == Null || Hud.ScoresTable == Null) return;

    declare cpProgress = Player::getCpProgress(_Player);
    declare usedJump = Player::usedJump(_Player);
    declare bestRun = Player::getBestRun(_Player);
    declare newBestTime = "--:--.--";

    if (bestRun > 0) {
        newBestTime = TL::TimeToText(bestRun, True);
    } else {
        newBestTime = "CP"^cpProgress;

        if (usedJump) {
            newBestTime = "$f33"^newBestTime^"$z";
        }
    }

    Hud.ScoresTable.SetColumnValue (_Player.Score, "BestTime", newBestTime);
}

/**
 * Update the column respawn counter
 *
 * Arguments: CSmPlayer _Player player to update
 */
Void Private_UpdatePlayerRsCounter(CSmPlayer _Player) {
    if (Hud == Null || Hud.ScoresTable == Null) return;
    Hud.ScoresTable.SetColumnValue (_Player.Score, "RS", Player::getRespawnCount(_Player));
}

/////////////////////////////////////////////////////////////////
/////////////////////   RESPAWN LOGIC   /////////////////////////
/////////////////////////////////////////////////////////////////

Void Private_RestartEffect(CSmPlayer _Player, Ident _SpawnId) {
    declare MapVersion = Map::GetMapTypeVersion();
    declare Spawn <=> MapLandmarks[_SpawnId];

    if (MapVersion <= 2) {
        declare WeaponType = Tools::GetWeaponTypeFromSpawn(Spawn);
        Weapons::ApplyWeaponForCheckpointType(_Player, WeaponType);
    } else {
        Weapons::ApplyEffects(_Player, Spawn);
    }
}

/**
 * Logic to respawn a player when he already have checkpoints and doesnt want to restart from the beginning
 *
 * Arguments: CSmPlayer _Player         Player to respawn
 *            Integer   _Delay          Activation delay for SM::Spawn
 *            Ident     _LastCheckpoint Id of the last checkpoint
 *            Ident     _CPSpawn        Id of the spawn if fast rs isnt possible
 *            Boolean   _Increment      should the rs counter be incremented (False when jumping to a cp)
 */
Void Private_CpRestart(CSmPlayer _Player, Integer _Delay, Ident _LastCheckpoint, Ident _CPSpawn, Boolean _Increment) {
    if (_Increment)
        Player::incrementRespawnCount(_Player);

    declare Checkpoint <=> MapLandmarks[_LastCheckpoint];
    declare Spawn <=> MapLandmarks_PlayerSpawn[_CPSpawn];
    declare CanFastRespawn = Settings::GetFastRespawn();

    // Check if fast respawn is possible
    if (CanFastRespawn) {
        declare metadata DefaultTag for  Checkpoint = "";
        if (DefaultTag != "Checkpoint" && DefaultTag != "" || Tools::IsPortal(Checkpoint))
            CanFastRespawn = False;
    }

    // Respawn player
    if (_Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned && CanFastRespawn)
        RespawnPlayer(_Player, Checkpoint.Waypoint);
    else
        SM::SpawnNoLadder(_Player, 0, Spawn.PlayerSpawn, Now + _Delay);

    XmlRpc.SendCallback("OnRespawn", _Player.User.Login);
}

/**
 * Shorthand for the function above without the increment parameter
 *
 * Arguments: CSmPlayer _Player         Player to respawn
 *            Integer   _Delay          Activation delay for SM::Spawn
 *            Ident     _LastCheckpoint Id of the last checkpoint
 *            Ident     _CPSpawn        Id of the spawn if fast rs isnt possible
 */
Void Private_CpRestart( CSmPlayer _Player, Integer _Delay, Ident _LastCheckpointId, Ident _CPSpawnId) {
    Private_CpRestart(_Player, _Delay, _LastCheckpointId, _CPSpawnId, True);
}

/**
 * Logic to spawn a player to the beginning of the map
 *
 * Arguments: CSmPlayer _Player Player to respawn
 *            Integer   _Delay  Activation delay for SM::Spawn
 */
Void Private_FullRestart(CSmPlayer _Player, Integer _Delay) {
    declare Spawn <=> MapLandmarks_PlayerSpawn[G_StartSpawnId];

    declare IsFirstRespawn = Player::getStartTime(_Player) <= 0;

    SM::SpawnNoLadder(_Player, 0, Spawn.PlayerSpawn, Now + _Delay);

    Private_RestartEffect(_Player, Spawn.Id);

    // Update values

    if (G_Mode != Constants::C_Mode_Sprint) {
        Player::setCpProgress(_Player, 0);
        Player::setUsedJump(_Player, False);
        Player::setRespawnCount(_Player, 0);
        Player::setStartTime(_Player, _Player.StartTime);
    }

    if (G_Mode == Constants::C_Mode_Sprint && IsFirstRespawn) {
        Player::setStartTime(_Player, _Player.StartTime);
    }


    Player::setLastCheckpoint(_Player, NullId);
    Player::clearLastCPTimes(_Player);

    // XmlRpc callback
    XmlRpc.SendCallback("OnRestart", _Player.User.Login);
}

/**
 * Respawn a player to the last cp or to the beginning
 *
 * Arguments: CSmPlayer _Player       Player to respawn
 *            Boolean   _forceRestart Force spawn to the beginning of the map
 */
Void ObsRespawnPlayer(CSmPlayer _Player, Boolean _forceRestart) {
    if (_Player.RequestsSpectate)
        return;

    if (!Player::isInitialized(_Player)) {
        NewPlayer(_Player);
    }

    declare shouldRestart = Player::wantsRestart(_Player, _forceRestart);
    declare LastCP = Player::getLastCheckpoint(_Player);
    declare Delay = -1;
    declare CPSpawnId = NullId;
    if (LastCP != NullId)
        CPSpawnId = Tools::GetClosestSpawn(LastCP);
    if (StartTime > Now + Delay)
        Delay = StartTime - Now;

    // Check if there is a cp spawn, if not we full restart
    if (CPSpawnId != NullId && !shouldRestart)
        Private_CpRestart(_Player, Delay, LastCP, CPSpawnId);
    else
        Private_FullRestart(_Player, Delay);

    /////////////////////////////////
    // Common behaviour after spawns

    if (G_Mode == Constants::C_Mode_Obstacle) {
       ObsScores::OnRespawnPlayer(_Player);
    }


    Private_UpdatePlayerBestTime(_Player); // update rs count

    if (Player::getBestRun(_Player) < 0) {
        Private_UpdatePlayerRsCounter(_Player);
    }

    Player::clearBuffTimes(_Player);

    if (Settings::GetFullAmmoSpawn()) {
        Weapons::FillUpPlayerAmmo(_Player);
    }
}

/**
 * Shorthand for the function above without the force restart parameter
 *
 * Arguments: CSmPlayer _Player       Player to respawn
 */
Void ObsRespawnPlayer(CSmPlayer _Player) {
    ObsRespawnPlayer(_Player, False);
}

/////////////////////////////////////////////////////////////////
///////////////////// CHECKPOINTS LOGIC /////////////////////////
/////////////////////////////////////////////////////////////////

/**
 * Logic to teleport a player using portal
 *
 * Arguments: CSmPlayer _Player Player to teleport
 *            Ident     _Portal Id of the portal landmark
 */
Void Private_UsePortal(CSmPlayer _Player, Ident _Portal) {
    declare SpawnId = Tools::GetClosestSpawn(_Portal);

    // Quit if there is no exit for the portal
    if (!MapLandmarks_PlayerSpawn.existskey(SpawnId))
        return;

    SM::SpawnNoLadder(_Player, 0, MapLandmarks_PlayerSpawn[SpawnId].PlayerSpawn);

    // Send message
    Message::SendBigMessage(_Player, _("Portal!"), 2500, 0);
}

/**
 * Jump a player to the desired checkpoint
 *
 * Arguments: CSmPlayer _Player Player to teleport
 *            Integer   _Target Order of the checkpoint to teleport to
 */
Void JumpToCheckpoint(CSmPlayer _Player, Integer _Target) {
    declare UI <=> UIManager.GetUI(_Player);
    if (_Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned || UI == Null)
        return;

    if (!Settings::GetAllowJump()) {
        UI.SendChat("$f00Jumping is disabled!$z");
        return;
    }

    // Search for the checkpoint to jump to
    declare CSmMapLandmark Target <=> Null;
    foreach (Landmark in MapLandmarks) {
        if (Tools::IsCheckpoint(Landmark) && Landmark.Order == _Target) {
            Target <=> Landmark;
            break;
        }
    }

    // Maybe all checkpoints are order 0
    // In this case it's a bit random and that sucks but who jumps in orderless maps anyway...
    if (Target == Null) {
        declare PoleIndex = 0;
        foreach (Landmark in MapLandmarks) {
            if (Tools::IsCheckpoint(Landmark) && PoleIndex == _Target) {
                Target <=> Landmark;
                break;
            }
            PoleIndex += 1;
        }
    }

    if (Target == Null) {
        UI.SendChat("$f11Cannot find Checkpoint "^_Target^"!$z");
        return;
    }

    declare Spawn = Tools::GetClosestSpawn(Target.Id);
    if (Spawn == NullId) {
        UI.SendChat("$f11Cannot find Spawn for Checkpoint "^_Target^"!$z");
        return;
    }

    UI.SendChat("$1f1Jumping to Checkpoint "^_Target^"!");

    Player::setUsedJump(_Player, True);
    Player::setLastCheckpoint(_Player, Target.Id);

    Private_CpRestart(_Player, 3500, Target.Id, Spawn, False);

    // TODO: Below is copy pasted in common behaviour after respawn
    Player::clearBuffTimes(_Player);

    if (Settings::GetFullAmmoSpawn()) {
        Weapons::FillUpPlayerAmmo(_Player);
    }
}

/**
 * Logic when a player capture the goal
 *
 * Arguments: CSmPlayer _Player Player who finish the map
 *            Ident     _GoalId Goal
 */
Void Private_HandleFinish(CSmPlayer _Player, Ident _GoalId) {
    declare Goal <=> MapLandmarks[_GoalId];

    declare BestRun = Player::getBestRun(_Player);
    declare Time = Player::getTime(_Player);

    Player::setLastRun(_Player, Time);
    Player::setLastCPTimes(_Player, _GoalId, Time);

    // Update time diff before updating best run
    TimeDiff::UpdateLayer(_Player, Time, BestRun);

    // Check if last run is  if last run is better
    if (Time < BestRun || BestRun < 0) {
        Player::setBestRun(_Player, Time);
        Player::setBestCPTimes(_Player, Player::getLastCPTimes(_Player));

        Private_UpdatePlayerRsCounter(_Player);

        CPTimes::UpdateLayer(_Player);
    }


    // Send score
    Private_SendFinishedRun(_Player, Time, _GoalId);
    XmlRpc.SendCallback("Obstacle_OnFinish", Player::ToJSON(_Player));

    //Update UI
    declare UI <=> UIManager.GetUI(_Player);
    if (UI != Null) {
        declare TimeStr = TL::TimeToText(Time, True);
        declare Variant = 1;
        declare Color = "$f00";

        declare message = "";
        if (Player::getBestRun(_Player) == Time) {
            Variant = 0;
            Color = "$00f";
            message = _("(New Best Time!)");
        }

        UI.SendNotice(TL::Compose("%1: $<%2$> %3", _("|Goal|Finish"), Color^TimeStr, message),
                CUIConfig::ENoticeLevel::PlayerInfo, _Player.User, CUIConfig::EAvatarVariant::Default,
                CUIConfig::EUISound::Finish, Variant);
    }
}

/* TODO: Make a separate checkpoint lib ?
 *
 * Effects:
 *  - Ammo:
 *   - ammo type
 *   - ammo gain (0% - 1000%)
 *   - ammo count
 *
 *  - Stamina:
 *   - Stamina amount (0% - 300%)
 *   - Stamina gain (0% - 100%)
 */
Void Private_CheckpointEffect(CSmPlayer _Player, Ident _CheckpointId) {
    declare MapVersion = Map::GetMapTypeVersion();
    declare Checkpoint <=> MapLandmarks[_CheckpointId];
    declare CheckpointName = Checkpoint.Tag;

    if (MapVersion <= 2) {
        if (TL::Length(CheckpointName) > 10) {
            declare CheckPointType = TL::ToInteger(TL::SubString(CheckpointName, 14, 1));
            switch (CheckPointType) {
                case 3: {
                            Private_UsePortal(_Player, _CheckpointId);
                        }
                default: {
                             Weapons::ApplyWeaponForCheckpointType(_Player, CheckPointType);
                         }
            }
        } else {
            Weapons::ApplyWeaponForCheckpointType(_Player, 0);
        }
    } else {
        Weapons::ApplyEffects(_Player, Checkpoint);

        declare metadata Meta_IsPortal for Checkpoint = False;
        if (Meta_IsPortal)
            Private_UsePortal(_Player, Checkpoint.Id);
    }
}

/**
 * Logic when a player capture a checkpoint
 *
 * Arguments: CSmPlayer _Player       Player who captured checkpoint
 *            Ident     _CheckpointId Checkpoint captured (guaranted to be the next cp)
 */
Void Private_HandleCheckpoint(CSmPlayer _Player, Ident _CheckpointId) {
    declare Checkpoint <=> MapLandmarks[_CheckpointId];
    declare LastCPTimes = Player::getLastCPTimes(_Player);
    declare BestCPTimes = Player::getBestCPTimes(_Player);

    declare time = Player::getTime(_Player);

    Player::setLastCPTimes(_Player, _CheckpointId, time);

    // lazy fix might not fix cp progress completely
    if (Player::usedJump(_Player) && Checkpoint.Order != 0)
        Player::setCpProgress(_Player, Checkpoint.Order);
    else
        Player::setCpProgress(_Player, LastCPTimes.count + 1);

    Player::setLastCheckpoint(_Player, _CheckpointId);
    Private_CheckpointEffect(_Player, _CheckpointId);

    XmlRpc.SendCallback("Obstacle_OnCheckpoint", Player::ToJSON(_Player));

    // UPDATE UI
    Private_UpdatePlayerBestTime(_Player);

    declare UI <=> UIManager.GetUI(_Player);
    if (_Player.Score == Null) return;
    declare Variant = 0;

    declare BestTime = Player::getBestTime(_Player, _CheckpointId);
    if (time > BestTime) Variant = 1;

    TimeDiff::UpdateLayer(_Player, time, BestTime);

    UI.SendNotice("",
            CUIConfig::ENoticeLevel::PlayerInfo, _Player.User, CUIConfig::EAvatarVariant::Default,
            CUIConfig::EUISound::Checkpoint, Variant);

    if (G_Mode == Constants::C_Mode_Obstacle) {
       ObsScores::OnCheckpoint(_Player);
    }
}

/**
 * Manage interactions between player and landmarks (checkpoints, goals, portals, more?)
 *
 * Arguments: CSmPlayer _Player Player who captured a landmark
 * Returns: True if the player captured a goal
 */
Boolean HandleCapture(CSmPlayer _Player) {
    declare HasCapturedGoal = False;

    declare Landmark <=> _Player.CapturedLandmark;
    declare MapVersion = Map::GetMapTypeVersion();
    declare CpProgress = Player::getCpProgress(_Player);
    declare HasJumped = Player::usedJump(_Player);
    declare MessageToShow = "";

    if (!Tools::IsEnabled(Landmark)) {
        return HasCapturedGoal;
    }

    declare Time = Player::getTime(_Player);
    if (Time < 0) {
        ObsRespawnPlayer(_Player, True);
        return HasCapturedGoal;
    }

    if (Tools::IsGoal(Landmark)) {
        if (HasJumped) {
            MessageToShow =  _("You used a Jump! Your Time is invalid.");
        }
        else {
            declare CpMissing = G_CheckpointsTotal - CpProgress;
            if (CpMissing == 0) {
                Private_HandleFinish(_Player, Landmark.Id);
                HasCapturedGoal = True;
            }
            else {
                MessageToShow = "Missing "^CpMissing^" checkpoint(s)!";
            }
        }
    }
    else if (Tools::IsCheckpoint(Landmark)) {
        // Take any checkpoints if player jumped
        if (HasJumped) {
            if (Landmark.Order != CpProgress) {
                Private_HandleCheckpoint(_Player, Landmark.Id);
            }
        }
        else {
            declare LastCpTimes = Player::getLastCPTimes(_Player);
            declare LastCheckpoint = Player::getLastCheckpoint(_Player);

            // Check if the checkpoint is the next one
            declare isNextCp = True;
            if (Landmark.Order == 0) {
                isNextCp = !LastCpTimes.existskey(Landmark.Id);
            } else {
                isNextCp = Landmark.Order == CpProgress + 1;
            }

            if (isNextCp) {
                Private_HandleCheckpoint(_Player, Landmark.Id);
            }
        }
    } else if (Tools::IsPortal(Landmark)) {
        Private_UsePortal(_Player, Landmark.Id);
    }

    // TODO: Change this to a separate function (in Tools or Player?)
    declare LastStatusMessage for _Player = Now;
    if (MessageToShow != "" && LastStatusMessage + 2500 < Now) {
        LastStatusMessage = Now;
        Message::SendBigMessage(_Player, MessageToShow, 2000, 0, CUIConfig::EUISound::Warning, 1);
    }

    return HasCapturedGoal;
}
