/*********************************************
* Obstacle Library                           *
* Author:  smokegun                          *
*                                            *
* Obstacle functions.                        *
*********************************************/

#Include "TextLib" as TextLib
#Include "MathLib" as MathLib

#Include "Libs/Nadeo/Json2.Script.txt" as Json
#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map
#Include "Libs/Nadeo/Ladder.Script.txt" as Ladder
#Include "Libs/Nadeo/ShootMania/SM3.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Scores.Script.txt" as Scores
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/Log.Script.txt" as Log
#Include "Libs/Nadeo/TabsServer.Script.txt" as Tabs

#Include "Libs/smokegun/Player.Script.txt" as Player
#Include "Libs/smokegun/Tools.Script.txt" as Tools
#Include "Libs/smokegun/Weapons.Script.txt" as Weapons
#Include "Libs/smokegun/UI.Script.txt" as ObsUI
#Include "Libs/smokegun/ObstacleRecords.Script.txt" as API

#Include "Libs/smokegun/CPTimes.Script.txt" as CPTimes


/*********************************************
	CONSTANTS
*********************************************/

#Const	Version		"2017-07-10"
#Const	ScriptName	"ObstacleLib.Script.txt"


/*********************************************
	GLOBALES
*********************************************/

// Map
declare Ident		G_StartSpawnId;
declare Integer G_CheckpointsTotal;

// Settings
declare	Boolean G_FullAmmoSpawn;
declare	Boolean G_FastRespawn;
declare Boolean G_LegacyRespawn;
declare Boolean G_AllowJump;


/*********************************************
	FUNCTIONS
*********************************************/

// TODO: handle settings better
Void SetSettings(	Boolean _FullAmmoSpawn
	, Boolean _FastRespawn
	, Boolean _LegacyRespawn
	, Boolean _AllowJump
) {
	G_FullAmmoSpawn = _FullAmmoSpawn;
	G_FastRespawn = _FastRespawn;
	G_LegacyRespawn = _LegacyRespawn;
	G_AllowJump = _AllowJump;
}

/**
 * Initialize a player
 * 
 */
Void NewPlayer(CSmPlayer _Player)
{
	Player::InitPlayer(_Player);
	API::ReplaceOrCreatePlayer(_Player);
	Ladder::AddPlayer(_Player.Score);

	declare UI <=> UIManager.GetUI(_Player);
	if (UI != Null) Tabs::UseTabs(UI, "ScoresTab");	
}

/**
 * Initialize the map (count cp, find spawn, send api request)
 * 
 * Returns: boolean is the map valid
 */
Boolean PrepareMap() {
	API::ReplaceOrCreateMap();

	G_StartSpawnId = NullId;
	G_CheckpointsTotal = 0;
	ObsUI::ResetMarkers();

	// Count checkpoints and init markers for portals
	// We save checkpoints to CheckpointOrders to count multiple checkpoints with the same order once
	declare CheckpointOrders = Integer[];	
	foreach (GaugeLandmark in MapLandmarks_Gauge) {
		GaugeLandmark.Gauge.ValueReal = 1.0;
		
		if (Tools::IsCheckpoint(GaugeLandmark)) {
			if (GaugeLandmark.Order == 0 || !CheckpointOrders.exists(GaugeLandmark.Order)) {
				G_CheckpointsTotal += 1;
				CheckpointOrders.add(GaugeLandmark.Order);
			}
		} else if (Tools::IsPortal(GaugeLandmark)) {
			ObsUI::PrepareMarkers(GaugeLandmark);
		}
	}

	// Publish the numbers of checkpoint for the UI
	declare netwrite Integer Net_CheckpointsTotal for Teams[0];
	Net_CheckpointsTotal = G_CheckpointsTotal;

	CPTimes::StartMap(G_CheckpointsTotal);

	// Search start spawn
	foreach (SpawnLandmark in MapLandmarks_PlayerSpawn) {
		if (Tools::IsSpawn(SpawnLandmark)) {
			G_StartSpawnId = SpawnLandmark.Id;
			break;
		}
	}

	//TODO: Show warning when playing old map, to prevent crash with fast rs and poles as cp

	if (!MapLandmarks_PlayerSpawn.existskey(G_StartSpawnId)) {
		Log::Log("ERROR: No Start Spawn on this Map!");
		UIManager.UIAll.SendChat("$f00ERROR: No Start Spawn on this Map!");
		return False;
	}

	return True;
}

/**
 * Update pole ids net variable for markers
 *
 * Arguments: CSmPlayer _Player the player who needs update
 */
Void Private_UpdatePoleIds(CSmPlayer _Player) {
	declare netwrite Text Net_PoleIds for _Player;
	declare CpProgress = Player::getCpProgress(_Player);

	declare PoleIds = Ident[];
	foreach (GaugeLandmark in MapLandmarks_Gauge) {
		if (GaugeLandmark.Tag == "No-Function") continue;
		if (GaugeLandmark.Tag == "Goal" && CpProgress < G_CheckpointsTotal) continue;
		
		if (GaugeLandmark.Tag == "Portal") {
			declare SpawnId = Tools::GetClosestSpawn(GaugeLandmark.Id);
			if (MapLandmarks_PlayerSpawn.existskey(SpawnId)) PoleIds.add(SpawnId);
		}
		
		if (GaugeLandmark.Order > 0 && GaugeLandmark.Order != CpProgress + 1) continue;
		PoleIds.add(GaugeLandmark.Id);
	}

	declare String = "";
	foreach (Index => PoleId in PoleIds) {
		String ^= PoleId;
		if (Index < PoleIds.count) String ^= ",";
	}

	Net_PoleIds = String;
}

/////////////////////////////////////////////////////////////////
///////////////////// XMLRPC CALLBACKS  /////////////////////////
/////////////////////////////////////////////////////////////////

/**
 * Send a xmlrpc callback with a predefined payload
 *
 */
Void Private_SendXmlRpcCallback(Text _CallbackName, CSmPlayer _Player, Integer _RunTime, Ident _CheckpointId) {
	if (_Player == Null || _Player.IsFakePlayer || _Player.Score == Null || _CallbackName == "" || _RunTime <= 0) return;

	declare JSON =
	"""{
		"Player":
		{
			"Name": "{{{Json::EscapeText(_Player.User.Name)}}}",
			"Login": "{{{Json::EscapeText(_Player.User.Login)}}}"
		},
		"Run":
		{
			"Time": {{{_RunTime}}},
			"RespawnCount": {{{Player::getRespawnCount(_Player)}}},
			"CheckpointIndex": {{{Player::getLastCPTimes(_Player).count - 1}}},
			"CheckpointId": "{{{_CheckpointId}}}"
		}
	}""";

	XmlRpc.SendCallback(_CallbackName, JSON);
}

/**
 * Side effects when a player finishes a run
 *   - XmlRpc for compatibility with controllers such as ManiaControl
 *   - Api to save records online
 *
 */
Void Private_SendFinishedRun(CSmPlayer _Player, Integer _Run, Ident _GoalId) {
	Private_SendXmlRpcCallback("OnFinish", _Player, _Run, _GoalId);
	API::PlayerFinished(_Player);
}

/////////////////////////////////////////////////////////////////
///////////////////// RANKING FUNCTIONS /////////////////////////
/////////////////////////////////////////////////////////////////

/** 
 * Update the scores of the players based on their best run or cp progress
 *
 */
Void Private_UpdateRanking() {
	declare Finished = Integer[Ident];
	declare Unfinished = CSmPlayer[];

	// Split finished and unfinished players
	foreach (Player in AllPlayers) {
		declare BestRun = Player::getBestRun(Player);
		if (BestRun > 0) Finished[Player.Id] = BestRun;
		else Unfinished.add(Player);
	}

	// Unfinished players score are based on checkpoints reached
	foreach (Player in Unfinished) {
		declare Points = Player::getLastCPTimes(Player).count;
		Scores::SetPlayerMapPoints(Player.Score, Points);
	}

	// Finished players scores are based on their ranking amongst themselves
	Finished = 	Finished.sort();
	declare rank = 0;
	foreach (Id => Time in Finished) {
		if(Players.existskey(Id)) {
			Scores::SetPlayerMapPoints(Players[Id].Score, G_CheckpointsTotal + Finished.count - rank);
		}
		rank += 1;
	}
}

/////////////////////////////////////////////////////////////////
///////////////////// SCORESTABLE SYNC  /////////////////////////
/////////////////////////////////////////////////////////////////

/**
 * Update the column best time
 *
 * Arguments: CSmPlayer _Player player to update
 */
Void Private_UpdatePlayerBestTime(CSmPlayer _Player) {	
	declare cpProgress = Player::getCpProgress(_Player);
	declare usedJump = Player::usedJump(_Player);
	declare bestRun = Player::getBestRun(_Player);
	declare newBestTime = "--:--.--";

	if(bestRun > 0) {
		newBestTime = TextLib::TimeToText(bestRun, True);
	} else {
		newBestTime = "CP"^cpProgress;
		
		if(usedJump) {
			newBestTime = "$f33"^newBestTime^"$z";
		}
	}
	
	Hud.ScoresTable.SetColumnValue (_Player.Score, "BestTime", newBestTime);
	Private_UpdateRanking();
}

/**
 * Update the column respawn counter
 *
 * Arguments: CSmPlayer _Player player to update
 */
Void Private_UpdatePlayerRsCounter(CSmPlayer _Player) {
	Hud.ScoresTable.SetColumnValue (_Player.Score, "RS", Player::getRespawnCount(_Player));
}

/////////////////////////////////////////////////////////////////
/////////////////////   RESPAWN LOGIC   /////////////////////////
/////////////////////////////////////////////////////////////////

/**
 * Logic to respawn a player when he already have checkpoints and doesnt want to restart from the beginning
 *
 * Arguments: CSmPlayer _Player         Player to respawn
 *            Integer   _Delay          Activation delay for SM::Spawn
 *            Ident     _LastCheckpoint Id of the last checkpoint
 *            Ident     _CPSpawn        Id of the spawn if fast rs isnt possible
 *            Boolean   _Increment      should the rs counter be incremented (False when jumping to a cp)
 */
Void Private_CpRestart(CSmPlayer _Player, Integer _Delay, Ident _LastCheckpoint, Ident _CPSpawn, Boolean _Increment) {
	if(_Increment)
		Player::incrementRespawnCount(_Player);
	
	declare Checkpoint <=> MapLandmarks_Gauge[_LastCheckpoint];
	declare Spawn <=> MapLandmarks_PlayerSpawn[_CPSpawn];
	declare CanFastRespawn = G_FastRespawn;
	
	// Check if fast respawn is possible
	if (CanFastRespawn) {
		declare metadata DefaultTag for  Checkpoint = "";		
		if (DefaultTag != "Checkpoint" && DefaultTag != "" || Tools::IsPortal(Checkpoint))
			CanFastRespawn = False;
	}

	// Respawn player
	if (_Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned && CanFastRespawn)
		RespawnPlayer(_Player, Checkpoint);
	else
		SM::SpawnNoLadder(_Player, 0, Spawn.PlayerSpawn, Now + _Delay);

	XmlRpc.SendCallback("OnRespawn", _Player.User.Login);
}

/**
 * Shorthand for the function above without the increment parameter
 *
 * Arguments: CSmPlayer _Player         Player to respawn
 *            Integer   _Delay          Activation delay for SM::Spawn
 *            Ident     _LastCheckpoint Id of the last checkpoint
 *            Ident     _CPSpawn        Id of the spawn if fast rs isnt possible
 */
Void Private_CpRestart(	CSmPlayer _Player, Integer _Delay, Ident _LastCheckpointId, Ident _CPSpawnId) {
	Private_CpRestart(_Player, _Delay, _LastCheckpointId, _CPSpawnId, True);
}

/**
 * Logic to spawn a player to the beginning of the map
 *
 * Arguments: CSmPlayer _Player Player to respawn
 *            Integer   _Delay  Activation delay for SM::Spawn
 */
Void Private_FullRestart(CSmPlayer _Player, Integer _Delay) {
	declare Spawn <=> MapLandmarks_PlayerSpawn[G_StartSpawnId];

	declare WeaponType = Tools::GetWeaponTypeFromSpawn(Spawn);
	Weapons::ApplyWeaponType(_Player, WeaponType);

	SM::SpawnNoLadder(_Player, 0, Spawn.PlayerSpawn, Now + _Delay);

	// Update values
	Player::setStartTime(_Player, _Player.StartTime);
	Player::setCpProgress(_Player, 0);
	Player::setUsedJump(_Player, False);
	Player::setRespawnCount(_Player, 0);
	Player::setLastCheckpoint(_Player, NullId);
	Player::clearLastCPTimes(_Player);

	// Update missing checkpoints
	Private_UpdatePoleIds(_Player);

	// XmlRpc callback
	XmlRpc.SendCallback("OnRestart", _Player.User.Login);
}

/**
 * Respawn a player to the last cp or to the beginning
 *
 * Arguments: CSmPlayer _Player       Player to respawn
 *            Boolean   _forceRestart Force spawn to the beginning of the map
 */
Void RespawnPlayer(CSmPlayer _Player, Boolean _forceRestart) {
	if (_Player.RequestsSpectate)
		return;

	if(!Player::isInitialized(_Player))
		NewPlayer(_Player);

	declare shouldRestart = Player::wantsRestart(_Player) || _forceRestart;
	declare LastCP = Player::getLastCheckpoint(_Player);
	declare Delay = 3500;
	declare CPSpawnId = NullId;	
	if(LastCP != NullId)
		CPSpawnId = Tools::GetClosestSpawn(LastCP);
	if (StartTime > Now + Delay)
		Delay = StartTime - Now;
	
	// Check if there is a cp spawn, if not we full restart
	if(CPSpawnId != NullId && !shouldRestart)
		Private_CpRestart(_Player, Delay, LastCP, CPSpawnId);
	else
		Private_FullRestart(_Player, Delay);

	/////////////////////////////////
	// Common behaviour after spawns
	
	Private_UpdatePlayerBestTime(_Player);
	if(Player::getBestRun(_Player) <= 0) {
		Private_UpdatePlayerRsCounter(_Player);
	}

	Player::clearItemBuff(_Player);

	// TODO: Make it works with full restart too
	if (G_FullAmmoSpawn) {
		Weapons::FillUpPlayerAmmo(_Player);
	}
}

/**
 * Shorthand for the function above without the force restart parameter
 *
 * Arguments: CSmPlayer _Player       Player to respawn
 */
Void RespawnPlayer(CSmPlayer _Player) {
	RespawnPlayer(_Player, False);
}

/////////////////////////////////////////////////////////////////
///////////////////// CHECKPOINTS LOGIC /////////////////////////
/////////////////////////////////////////////////////////////////

/**
 * Logic to teleport a player using portal
 *
 * Arguments: CSmPlayer _Player Player to teleport
 *            Ident     _Portal Id of the portal landmark
 */
Void Private_UsePortal(CSmPlayer _Player, Ident _Portal) {
	declare SpawnId = Tools::GetClosestSpawn(_Portal);
	
	// Quit if there is no exit for the portal
	if (!MapLandmarks_PlayerSpawn.existskey(SpawnId))
		return;

	SM::SpawnNoLadder(_Player, 0, MapLandmarks_PlayerSpawn[SpawnId].PlayerSpawn);

	// Send message
	Message::SendBigMessage(_Player, _("Portal!"), 2500, 0);
}

/**
 * Jump a player to the desired checkpoint
 *
 * Arguments: CSmPlayer _Player Player to teleport
 *            Integer   _Target Order of the checkpoint to teleport to
 */
Void JumpToCheckpoint(CSmPlayer _Player, Integer _Target) {
	declare UI <=> UIManager.GetUI(_Player);
	if (_Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned || UI == Null)
		return;

	if (!G_AllowJump) {
		UI.SendChat("$f00Jumping is disabled!$z");
		return;
	}

	// Search for the checkpoint to jump to
	declare CSmMapLandmark Target <=> Null;
	foreach (Landmark in MapLandmarks_Gauge) {
		if (Tools::IsCheckpoint(Landmark) && Landmark.Order == _Target) {
			Target <=> Landmark;
			break;
		}
	}
	
	// Maybe all checkpoints are order 0
	// In this case it's a bit random and that sucks but who jumps in orderless maps anyway...
	if (Target == Null) {
		declare PoleIndex = 0;
		foreach (Landmark in MapLandmarks_Gauge) {
			if (Tools::IsCheckpoint(Landmark) && PoleIndex == _Target) {
				Target <=> Landmark;
				break;
			}
			PoleIndex += 1;
		}
	}	
	if (Target == Null) {
		UI.SendChat("$f11Cannot find Checkpoint "^_Target^"!$z");
		return;
	}	

	declare Spawn = Tools::GetClosestSpawn(Target.Id);	
	if(Spawn == NullId) {
		UI.SendChat("$f11Cannot find Spawn for Checkpoint "^_Target^"!$z");
		return;
	}
	
	UI.SendChat("$1f1Jumping to Checkpoint "^_Target^"!");
	Player::setUsedJump(_Player, True);
	Player::setLastCheckpoint(_Player, Target.Id);
	Private_CpRestart(_Player, 3500, Target.Id, Spawn, False);
	
	// TODO: Below is copy pasted in common behaviour after respawn
	Player::clearItemBuff(_Player);
	// TODO: Make it works with full restart too
	if (G_FullAmmoSpawn) {
		Weapons::FillUpPlayerAmmo(_Player);
	}
}

/**
 * Logic when a player capture the goal
 *
 * Arguments: CSmPlayer _Player Player who finish the map
 *            Ident     _GoalId Goal
 */
Void Private_HandleFinish(CSmPlayer _Player, Ident _GoalId) {
	declare LastCPTimes = Player::getLastCPTimes(_Player);
	declare BestCPTimes = Player::getBestCPTimes(_Player);
	declare Goal <=> MapLandmarks_Gauge[_GoalId];
	declare BestRun = Player::getBestRun(_Player);
	
	declare time = Player::getTime(_Player);	
	declare LastRun = Player::setLastRun(_Player, time);
	
	LastCPTimes = Player::setLastCPTimes(_Player, _GoalId, time);
	
	// Update time diff before updating best run
	ObsUI::UpdateLayerTimeDiff(_Player, LastRun, BestRun);
	
	// Check if last run is  if last run is better
	if (LastRun < BestRun || BestRun < 0) {
		BestRun = Player::setBestRun(_Player, LastRun);
		BestCPTimes = Player::setBestCPTimes(_Player, LastCPTimes);
		
		CPTimes::UpdatePlayer(_Player);
	}

	// Send score
	Private_SendFinishedRun(_Player, LastRun, _GoalId);

	//Update UI
	declare UI <=> UIManager.GetUI(_Player);
	if (UI != Null) {
		declare Time = TextLib::TimeToText(LastRun, True);
		declare Variant = 1;
		declare Color = "$f00";

		declare message = "";
		if (BestRun == LastRun) {
			Variant = 0;
			Color = "$00f";
			message = _("(New Best Time!)");
		}

		UI.SendNotice(TextLib::Compose("%1: $<%2$> %3", _("|Goal|Finish"), Color^Time, message),
			CUIConfig::ENoticeLevel::PlayerInfo, _Player.User, CUIConfig::EAvatarVariant::Default,
			CUIConfig::EUISound::Finish, Variant);
	}

	RespawnPlayer(_Player, True);
}

/**
 * Logic when a player capture a checkpoint
 *
 * Arguments: CSmPlayer _Player       Player who captured checkpoint
 *            Ident     _CheckpointId Checkpoint captured (guaranted to be the next cp)
 */
Void Private_HandleCheckpoint(CSmPlayer _Player, Ident _CheckpointId) {
	declare LastCPTimes = Player::getLastCPTimes(_Player);
	declare BestCPTimes = Player::getBestCPTimes(_Player);
	declare Checkpoint <=> MapLandmarks_Gauge[_CheckpointId];
	
	declare time = Player::getTime(_Player);
	
	Player::setLastCPTimes(_Player, _CheckpointId, time);
	Player::setCpProgress(_Player, LastCPTimes.count + 1);
	Player::setLastCheckpoint(_Player, _CheckpointId);
	
	// Apply special checkpoints effect
	declare CheckpointName = Checkpoint.Tag;
	// special checkpoint
	if (TextLib::Length(CheckpointName) > 10) {
		declare CheckPointType = TextLib::ToInteger(TextLib::SubString(CheckpointName, 14, 1));
		switch (CheckPointType) {
			case 3: {
				Private_UsePortal(_Player, _CheckpointId);
			}
			default: {
				Weapons::ApplyWeaponType(_Player, CheckPointType);
			}
		}
	} else {
		Weapons::ApplyWeaponType(_Player, 0);
	}

	// UPDATE UI
  Private_UpdatePoleIds(_Player);
	Private_UpdatePlayerBestTime(_Player);
	
	declare UI <=> UIManager.GetUI(_Player);
	if (_Player.Score == Null) return;	
	declare Variant = 0;
	
	declare BestTime = Player::getBestTime(_Player, _CheckpointId);
	if(time > BestTime) Variant = 1;

	ObsUI::UpdateLayerTimeDiff(_Player, time, BestTime);

	UI.SendNotice("",
			CUIConfig::ENoticeLevel::PlayerInfo, _Player.User, CUIConfig::EAvatarVariant::Default,
			CUIConfig::EUISound::Checkpoint, Variant);
}

/**
 * Manage interactions between player and landmarks (checkpoints, goals, portals, more?)
 *
 * Arguments: CSmPlayer _Player Player who captured a landmark
 */
Void HandleCapture(CSmPlayer _Player) {
	declare Landmark <=> _Player.CapturedLandmark;
	declare CpProgress = Player::getCpProgress(_Player);
	declare HasJumped = Player::usedJump(_Player);
	declare MessageToShow = "";

	switch (Landmark.Tag) {
	
		case "Goal": {
			if (HasJumped) {
				MessageToShow =  _("You used a Jump! Your Time is invalid.");
			} else {
				declare CpMissing = G_CheckpointsTotal - CpProgress;
				if (CpMissing == 0) {
					Private_HandleFinish(_Player, Landmark.Id);
				} else {
					MessageToShow = "Missing "^CpMissing^" checkpoint(s)!";					
				}
			}
		}
		
		case "No-Function": {
			MessageToShow = _("Inactive Pole!");
		}
		
		case "Portal": {
			Private_UsePortal(_Player, Landmark.Id);
		}
		
		// case "Checkpoint" is not possible here
		// because tags are "CheckpointTypeXX" or just "Checkpoint"
		default: {
			if(!Tools::IsCheckpoint(Landmark))
				return;
		
			// Take any checkpoints if player jumped
			if(HasJumped) {
				if(Landmark.Order != CpProgress) {
					Private_HandleCheckpoint(_Player, Landmark.Id);
				}
				return;
			}
			
			declare LastCpTimes = Player::getLastCPTimes(_Player);
			declare LastCheckpoint = Player::getLastCheckpoint(_Player);
			
			// Check if the checkpoint is the next one
			declare isNextCp = True;
			if(Landmark.Order == 0) {
				isNextCp = !LastCpTimes.existskey(Landmark.Id);
			} else {
				isNextCp = Landmark.Order == CpProgress + 1;
			}
			
			if(isNextCp)
				Private_HandleCheckpoint(_Player, Landmark.Id);
			else if (Landmark.Id != LastCheckpoint)
				MessageToShow = "Wrong checkpoint !";
		}
		
	}

	// TODO: Change this to a separate function (in Tools or Player?)
	declare LastStatusMessage for _Player = Now;	
	if(MessageToShow != "" && LastStatusMessage + 2500 < Now) {
		LastStatusMessage = Now;
		Private_UpdatePoleIds(_Player);
		Message::SendBigMessage(_Player, MessageToShow, 2000, 0, CUIConfig::EUISound::Warning, 1);
	}
}